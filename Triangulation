

--contains list of vertices, ''pointers'' to triangles in it
--.Vertices is list of vertices 
--AT, BT, CT, nT pointers to 4 smaller triangles (sharing vertices with old A, B, C, and none)
--SHOULD THIS ALSO CONTAIN ITS OWN INDEX?? I THINK YES, since 
Triangle=new Type of MutableHashTable;

--contains a triple (which is its xyz coordinates), as well as a ''valid'' boolaean (to denote if thrown out or not)
Vertex=new Type of MutableHashTable;

--Macualay2 doesn't have amortizes O(1) push back, so I implement it myself *sigh*
--contains .theLength for USED length, and .theCnts for its contents
cppVector=new Type of MutableHashTable;

--R: a cppVector arr and any element x
--M: the cppVector arr, both theCnts and theLength
--E: in amortized O(1) time, adds in element to end, returns index where element was added
--pushBack=method();
--pushBack(cppVector, Triangle):=(arr, x)->{
pushBack:=(arr, x)->{
    if arr.theLength < #(arr.theCnts) then (
        (arr.theCnts)#(arr.theLength)=x;
        a=arr.theLength;
        arr.theLength=a+1;
    ) else (
       arr.theCnts= join(arr.theCnts, (arr.theLength: null));
       (arr.theCnts)#(arr.theLength)=x;
       a=arr.theLength;
       arr.theLength=a+1;
    );

    return (arr.theLength)-1;
}
--makes it easier to grab elements from the vector
cppVector @ ZZ:=(arr,i)-> {return (arr.theCnts)#i;};
--debugging below
--arr1=new cppVector from {theCnts=>new MutableList, theLength=>0};
--print peek arr1;
--pushBack(arr1,{1});
--print peek arr1;

--R: nothing
--M: nothing
--E: returns a random point on the unit sphere in R^3
randomS2point=()->{
    a:=random(RR);
    b:=random(RR);
    c:=random(RR);
    d:=1.0/sqrt(a*a+b*b+c*c);
    return {a*d, b*d, c*d};
};

--returns midpoint of two vertices
--NOT NORMALIZED!
Vertex + Vertex:=(x,y)-> new Vertex from {
    Points=>{0.5*(x.Points#0+y.Points#0), 0.5*(x.Points#1+y.Points#1), 0.5*(x.Points#2+y.Points#2)},
    valid=>true
};


--projects them down to xy axis, returns them in order so that they bound a regular polygon
  --i.e., the polygon does not intersect itself
--R: 4 points of type Vertex, sorted by x-coordinate (!)
--M: none
--E: returns 4 points sorted so that they bound a regular polygon
sortSquare=method();
sortSquare(Vertex, Vertex, Vertex, Vertex):=(a,b,c,d)->{
    assert(a.Points#0<= b.Points#0 and b.Points#0<= c.Points#0 and c.Points#0<= d.Points#0);
    s:=new MutableList from {a};
    e:=new MutableList from {d};
    
    --see if b, c lie above the line connecting ad
    --compute cross product of (ab,bd); (ac, cd); in 2d projection
    --if cross product is positive, then is below; negative then is above
    v:=[(d.Points#0)-(a.Points#0),(d.Points#1)-(a.Points#1)];
    vForB:=[(d.Points#0)-(b.Points#0), (d.Points#1)- (b.Points#1)];
    vForC:=[(d.Points#0)-(c.Points#0), (d.Points#1)- (c.Points#1)];
    
    if v_0 * vForB_1 - v_1 * vForB_0 < 0 then (--so b is below the line
        s=append(s, b);
    ) else (
        e=append(e, b);
    );
    
    if v_0 * vForC_1 - v_1* vForC_0 < 0 then (--so b is below the line
        s=append(s, c);
    ) else (
        e=append(e, c);
    );

    --now need to sort s (resp. e) be x-coordingate in increasing (resp. decreasing) order
    --do not need to sort s if it has 2 elements, since (s_0).Points#0 is least number, so already will be in inc order
    if #s>2 then (--just swap last 2 vertices if needed
        if (s#1).Points#0 > (s#2).Points#0 then (
            temp=s#1;
            s#1 =s#2;
            s#2 =temp;
        );
    );

    --now for e, this needs to be sorted in decreasing order 
    --(d was put at the beginning so again, only need to look at last 2 elements if #e>2
    if #e>2 then (--just swap last 2 vertices if needed
        if (e#1).Points#0 < (e#2).Points#0 then (
            temp=e#1;
            e#1 =e#2;
            e#2 =temp;
        );
    );
        
    return(toSequence(join(s,e)));
};

--quick test below to make sure that squareSort actually works
--a=new Vertex from {Points=> {.0877284,.134503,.987022}, valid=>true};
--b=new Vertex from {Points=> {.76403,.0742533,.640894}, valid=>true};
--c=new Vertex from {Points=> {.830945,.143911,.53742}, valid=>true};
--d=new Vertex from {Points=> {.936365,.254446,.241821}, valid=>true};



--creates initial 6 vertices (8 level zero triangles); puts them in levels
--R: none
--M: none
--E: returns mutable list of levels (a list of list of triangles), list of vertices, and
     --hashtable w/ key =index of vertice from the list, value= triangles the vertex lies in
initializeLevelZero=method();
initializeLevelZero(cppVector, cppVector, cppVector):=(triangleList, vertexIndexList, vertexTC)->{
    basePT:= new Vertex from {Points=> {0,0,-1} , valid=> true};
    pushBack(vertexIndexList,basePT);
    
    topPT:= new Vertex from {Points=> {0,0,1}, valid=> true}; 
    pushBack(vertexIndexList, topPT);
    
    a;b;c;d;
    --other 4 points which make up our initial triangulation
    pt1:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    pushBack(vertexIndexList, pt1);
    
    pt2:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    pushBack(vertexIndexList, pt2);
    
    --projecting down to xy-axis, have a be the left point and b be the right point
    if (pt1.Points)#0 < (pt2.Points)#0 then (a=pt1; b=pt2;) else (a=pt2; b=pt1;);
    
    pt3:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    pushBack(vertexIndexList,pt3);
    if (pt3.Points)#0 < (a.Points)#0 then (
        c=b; b=a; a=pt3;
    ) else if pt3.Points#0<b.Points#0 then (
        c=b; b=pt3;
    ) else (
       c=pt3;
    );
    
    pt4:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    pushBack(vertexIndexList, pt4);
    if pt4.Points#0 < c.Points#0 then (
        d=c;
        if pt4.Points#0<b.Points#0 then (
            c=b;
            if pt4.Points#0<a.Points#0 then (
                b=a; a=pt4;
            ) else (
                b=pt4;
            );
        ) else (
            c=pt4;
        );
    ) else (--is NOT left of c, so is right of c
      d=pt4;
    );
    --now a,b,c,d are points sorted by their x coordinates
    
    --print peek a
    --print peek b
    --print peek c
    --print peek d
    
    --sorts these points so that their projection bounds a regular (non self intersecting polygon)
    {a,b,c,d}=sortSquare(a,b,c,d);
    
    t1:=new Triangle from {Vertices=> {basePT, a, b}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>0};
    t2:=new Triangle from {Vertices=> {basePT, b, c}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>1};
    t3:=new Triangle from {Vertices=> {basePT, c, d}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>2};
    t4:=new Triangle from {Vertices=> {basePT, d, a}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>3};
    t5:=new Triangle from {Vertices=> {topPT, a, b}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>4};
    t6:=new Triangle from {Vertices=> {topPT, b, c}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>5};
    t7:=new Triangle from {Vertices=> {topPT, c, d}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>6};
    t8:=new Triangle from {Vertices=> {topPT, d, a}, AT=>null, BT=>null, CT=>null, nT=>null, Index=>7};
    
    --associate triangles to vertices by inclusion
    for i in 0..7 do (pushBack(vertexTC, new cppVector from {theCnts=> new MutableList from {}, theLength=> 0}));
    
    pushBack((vertexTC@0), t1);
    pushBack((vertexTC@0), t2);
    pushBack((vertexTC@0), t3);
    pushBack((vertexTC@0), t4);    
    
    pushBack((vertexTC@1), t5);
    pushBack((vertexTC@1), t6);
    pushBack((vertexTC@1), t7);
    pushBack((vertexTC@1), t8);
    
    --VERY MUCH NEED TO CHECK IN ON LATER
    --I supposed we can do triangle containment for the other points when we actually jump to that point
    
    
    --these 8 triangles make up the level 0 triangulation
    triangleList={t1, t2, t3, t4, t5, t6, t7, t8};
    
    --pushBack(vertexIndexList, a);
    --pushBack(vertexIndexList, b);
    --pushBack(vertexIndexList, c);
    --pushBack(vertexIndexList, d);
    
};

--
--R: Levels#levelNum#triangleNum is the face to be midpointed
--M: 
--E:
createLowerTriangle=(levelNum, triangleNum)->{
    --get vertices of the triangle
    a:=level#triangleNum#0;
    b:=level#triangleNum#1;
    c:=level#triangleNum#2;
    
    --new* is labeled as opposite from vertex *
    newA:=b+c;
    newB:=a+c;
    newC:=a+b;
    
    --NEED TO NORMALIZE THE POINTS (so that they actually lie on the sphere)
    
    
};

--CHECK: need something to update triangles that the point is in




triangleList=new cppVector from {theCnts=>new MutableList from {}, theLength=>0}; 
vertexIndexList=new cppVector from {theCnts=>new MutableList from {}, theLength=>0}; --is list of vertices

--vertex triangle containment list
--index of vertex from above corr to partial list of triangles that the vertex lies in
vertexTC=new cppVector from {theCnts=>new MutableList from {}, theLength=>0}; 





time initializeLevelZero(triangleList, vertexIndexList, vertexTC)

for i in 0..(triangleList.theLength-1) do print peek triangleList@i

for x in vertexIndexList.theCnts do print peek x

--NOW SHOULD check vertexTC, this is really important!!

-*
func1=()->{
b=new cppVector from {theCnts=>new MutableList, theLength=>0};
for i in 0..10 do( pushBack(b, {i}); );
--print peek b.theCnts;
--print peek b.theLength;
};

func2=()->{
c=new MutableList from (1000:null);
for i in 0..1024 do (c#i={i});
};

func3=(b)->{ for i in 0..1023 do( pushBack(b, {i}); );};

time func1();
time func2();
c=new cppVector from {theCnts=>new MutableList, theLength=>0};
print peek c;
time func3(c);
print peek c;
*-


