Triangle=new Type of MutableHashTable;
LevelList=new Type of MutableList;
--SingleLevel=new Type of MutableHashTable;
VertexTriangleContanment= new Type of MutableHashTable;
Vertex=new Type of MutableHashTable;

maxLevel=3;
assert(maxLevel>0);


--level=new LevelList from {Indices => new MutableHashTable from {} };
level=new LevelList from {0..maxLevel};
vertexIndexList=new MutableList from {0..5}; --is list of vertices
--vertex triangle containment list
--index of vertex from above corr to partial list of triangles that the vertex lies in
vertexTC=new VertexTriangleContanment from {}; 

--R: nothing
--M: nothing
--E: returns a random point on the unit sphere in R^3
--
randomS2point=()->{
    a:=random(RR);
    b:=random(RR);
    c:=random(RR);
    d:=1.0/sqrt(a*a+b*b+c*c);
    return {a*d, b*d, c*d};
};

--projects them down to xy axis, returns them in order so that they bound a regular polygon
  --i.e., the polygon does not intersect itself
--R: 4 points of type Vertex, sorted by x-coordinate (!)
--M: none
--E: returns 4 points sorted so that they bound a regular polygon
sortSquare=method();
sortSquare(Vertex, Vertex, Vertex, Vertex):=(a,b,c,d)->{
    assert(a.Points#0<= b.Points#0 and b.Points#0<= c.Points#0 and c.Points#0<= d.Points#0);
    s={a};
    e={d};
    
    --see if b, c lie above the line connecting ad
    --compute cross product of (ab,bd); (ac, cd); in 2d projection
    --if cross product is positive, then is below; negative then is above
    v=[(d.Points#0)-(a.Points#0),(d.Points#1)-(a.Points#1)];
    vForB=[(d.Points#0)-(b.Points#0), (d.Points#1)- (b.Points#1)];
    vForC=[(d.Points#0)-(c.Points#0), (d.Points#1)- (c.Points#1)];
    
    if v_0 * vForB_1 - v_1 * vForB_0 < 0 then (--so b is below the line
        s=append(s, b);
    ) else (
        e=append(e, b);
    );
    
    if v_0 * vForC_1 - v_1* vForC_0 < 0 then (--so b is below the line
        s=append(s, c);
    ) else (
        e=append(e, c);
    );

    --now need to sort s, e be x coordingate in increasing and decreasing order!!

    return(toSequence(join(s,e)));
};


--creates initial 6 vertices (8 level zero triangles); puts them in levels
--R: none
--M: none
--E: returns mutable list of levels (a list of list of triangles), list of vertices, and
     --hashtable w/ key =index of vertice from the list, value= triangles the vertex lies in
initializeLevelZero=method();
initializeLevelZero(LevelList, MutableList, VertexList):=(level, vertexIndexList, vertexTC)->{
    basePT:= new Vertex from {Points=> {0,0,-1} , valid=> true};
    vertexIndexList#0=basePT;
    
    topPT:= new Vertex from {Points=> {0,0,1}, valid=> true}; 
    vertexIndexList#1=topPT;
    
    a;b;c;d;
    --other 4 points which make up our initial triangulation
    pt1:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#2=pt1;
    pt2:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#3=pt2;
    
    --projecting down to xy-axis, have a be the left point and b be the right point
    if pt1.Points#0<pt2.Points#0 then (a=pt1; b=pt2) else (a=pt2; b=pt1);
    
    pt3:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#4=pt3;
    if pt3.Points#0< a.Points#0 then (
        c=b; b=a; a=pt3;
    ) else if pt3.Points#0<b.Points#0 then (
        c=b; b=pt3;
    ) else (
       c=pt3;
    );
    
    pt4:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#5=pt4;
    if pt4.Points#0 < c.Points#0 then (
        d=c;
        if pt4.Points#0<b.Points#0 then (
            c=b;
            if pt4.Points#0<a.Points#0 then (
                b=a; a=pt4;
            ) else (
                b=pt4;
            );
        ) else (
            c=pt4;
        );
    ) else (--is NOT left of c, so is right of c
      d=pt4;
    );
    --now a,b,c,d are points sorted by their x coordinates
    
    print peek a
    print peek b
    print peek c
    print peek d
    
    --sorts these points so that their projection bounds a regular (non self intersecting polygon)
    {a,b,c,d}=sortSquare(a,b,c,d);
    
   
    
    --need to edit vertexTC
    
    --HERE! add the 8 triangles to level#0
    
    
    -- creates empty rows of garbage values to ensure when O(numLevel) search for triangle containment occurs,
      --one can actually traverse down correctly
      --(i.e., index of lower faces do not change when other faces of same level are created
    for i from 1 to maxLevel do (
        level#i=new MutableList from (8*4^i:null); --there is a maximum of 8(4^i) triangles at each level
    );
    
};

--
--R: Levels#level#numTriangle is the face to be midpointed
--M: 
--E:
createLowerTriangle=(level, numTriangle)->{
    
    
};

--need something to update triangles that the point is in

t1=new Triangle from {1,2,3,4};

stuff=new MutableList from {t1,t1};
stuff#0#3=null
peek stuff#0
peek stuff#1
peek t1

stuff2={}
stuff2=append(stuff2, stuff#0)
peek stuff2#0
