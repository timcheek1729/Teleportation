Triangle=new Type of List;
LevelList=new Type of MutableList;
--SingleLevel=new Type of MutableHashTable;
VertexTriangleContanment= new Type of MutableHashTable;
Vertex=new Type of MutableHashTable;


--R: nothing
--M: nothing
--E: returns a random point on the unit sphere in R^3
--
randomS2point=()->{
    a:=random(RR);
    b:=random(RR);
    c:=random(RR);
    d:=1.0/sqrt(a*a+b*b+c*c);
    return {a*d, b*d, c*d};
};

--projects them down to xy axis, returns them in order so that they bound a regular polygon
  --i.e., the polygon does not intersect itself
--R: 4 points of type Vertex, sorted by x-coordinate (!)
--M: none
--E: returns 4 points sorted so that they bound a regular polygon
sortSquare=method();
sortSquare(Vertex, Vertex, Vertex, Vertex):=(a,b,c,d)->{
    assert(a.Points#0<= b.Points#0 and b.Points#0<= c.Points#0 and c.Points#0<= d.Points#0);
    s:=new MutableList from {a};
    e:=new MutableList from {d};
    
    --see if b, c lie above the line connecting ad
    --compute cross product of (ab,bd); (ac, cd); in 2d projection
    --if cross product is positive, then is below; negative then is above
    v:=[(d.Points#0)-(a.Points#0),(d.Points#1)-(a.Points#1)];
    vForB:=[(d.Points#0)-(b.Points#0), (d.Points#1)- (b.Points#1)];
    vForC:=[(d.Points#0)-(c.Points#0), (d.Points#1)- (c.Points#1)];
    
    if v_0 * vForB_1 - v_1 * vForB_0 < 0 then (--so b is below the line
        s=append(s, b);
    ) else (
        e=append(e, b);
    );
    
    if v_0 * vForC_1 - v_1* vForC_0 < 0 then (--so b is below the line
        s=append(s, c);
    ) else (
        e=append(e, c);
    );

    --now need to sort s (resp. e) be x-coordingate in increasing (resp. decreasing) order
    --do not need to sort s if it has 2 elements, since (s_0).Points#0 is least number, so already will be in inc order
    if #s>2 then (--just swap last 2 vertices if needed
        if (s#1).Points#0 > (s#2).Points#0 then (
            temp=s#1;
            s#1 =s#2;
            s#2 =temp;
        );
    );

    --now for e, this needs to be sorted in decreasing order 
    --(d was put at the beginning so again, only need to look at last 2 elements if #e>2
    if #e>2 then (--just swap last 2 vertices if needed
        if (e#1).Points#0 < (e#2).Points#0 then (
            temp=e#1;
            e#1 =e#2;
            e#2 =temp;
        );
    );
        
    return(toSequence(join(s,e)));
};

--quick test below to make sure that squareSort actually works
--a=new Vertex from {Points=> {.0877284,.134503,.987022}, valid=>true};
--b=new Vertex from {Points=> {.76403,.0742533,.640894}, valid=>true};
--c=new Vertex from {Points=> {.830945,.143911,.53742}, valid=>true};
--d=new Vertex from {Points=> {.936365,.254446,.241821}, valid=>true};



--creates initial 6 vertices (8 level zero triangles); puts them in levels
--R: none
--M: none
--E: returns mutable list of levels (a list of list of triangles), list of vertices, and
     --hashtable w/ key =index of vertice from the list, value= triangles the vertex lies in
initializeLevelZero=method();
initializeLevelZero(LevelList, MutableList, VertexTriangleContanment):=(level, vertexIndexList, vertexTC)->{
    basePT:= new Vertex from {Points=> {0,0,-1} , valid=> true};
    vertexIndexList#0=basePT;
    
    topPT:= new Vertex from {Points=> {0,0,1}, valid=> true}; 
    vertexIndexList#1=topPT;
    
    a;b;c;d;
    --other 4 points which make up our initial triangulation
    pt1:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#2=pt1;
    pt2:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#3=pt2;
    
    --projecting down to xy-axis, have a be the left point and b be the right point
    if pt1.Points#0<pt2.Points#0 then (a=pt1; b=pt2) else (a=pt2; b=pt1);
    
    pt3:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#4=pt3;
    if pt3.Points#0< a.Points#0 then (
        c=b; b=a; a=pt3;
    ) else if pt3.Points#0<b.Points#0 then (
        c=b; b=pt3;
    ) else (
       c=pt3;
    );
    
    pt4:=new Vertex from {Points=> randomS2point(), valid=> true}; 
    vertexIndexList#5=pt4;
    if pt4.Points#0 < c.Points#0 then (
        d=c;
        if pt4.Points#0<b.Points#0 then (
            c=b;
            if pt4.Points#0<a.Points#0 then (
                b=a; a=pt4;
            ) else (
                b=pt4;
            );
        ) else (
            c=pt4;
        );
    ) else (--is NOT left of c, so is right of c
      d=pt4;
    );
    --now a,b,c,d are points sorted by their x coordinates
    
    --print peek a
    --print peek b
    --print peek c
    --print peek d
    
    --sorts these points so that their projection bounds a regular (non self intersecting polygon)
    {a,b,c,d}=sortSquare(a,b,c,d);
    
    t1:=new Triangle from {basePT, a, b};
    t2:=new Triangle from {basePT, b, c};
    t3:=new Triangle from {basePT, c, d};
    t4:=new Triangle from {basePT, d, a};
    t5:=new Triangle from {topPT, a, b};
    t6:=new Triangle from {topPT, b, c};
    t7:=new Triangle from {topPT, c, d};
    t8:=new Triangle from {topPT, d, a};
    
    --associate triangles to vertices by inclusion
    --is basepoint
    vertexTC#0=new MutableHashTable from {Triangles=> new MutableList from {t1,t2,t3,t4}, Levels=>new MutableList from {0,0,0,0}, Indices=>new MutableList from{0,1,2,3}};
    
    --is top point
    vertexTC#1=new MutableHashTable from {Triangles=> new MutableList from {t5,t6,t7,t8}, Levels=>new MutableList from {0,0,0,0}, Indices=>new MutableList from{4,5,6,7}};
    
    --VERY MUCH NEED TO CHECK IN ON LATER
    --I supposed we can do triangle containment for the other points when we actually jump to that point
    
    
    --these 8 triangles make up the level 0 triangulation
    level#0={t1, t2, t3, t4, t5, t6, t7, t8};
   
    -- creates empty rows of garbage values to ensure when O(numLevel) search for triangle containment occurs,
      --one can actually traverse down correctly
      --(i.e., index of lower faces do not change when other faces of same level are created
    for i from 1 to maxLevel do (
        level#i=new MutableList from (8*4^i:null); --there is a maximum of 8(4^i) triangles at each level
    );
    
};

--
--R: Levels#level#numTriangle is the face to be midpointed
--M: 
--E:
createLowerTriangle=(level, numTriangle)->{
    
    
};

--need something to update triangles that the point is in


maxLevel=3;
assert(maxLevel>0);


--level=new LevelList from {Indices => new MutableHashTable from {} };
level=new LevelList from {0..maxLevel};
vertexIndexList=new MutableList from {0..5}; --is list of vertices
--vertex triangle containment list
--index of vertex from above corr to partial list of triangles that the vertex lies in
vertexTC=new VertexTriangleContanment from {}; 

time initializeLevelZero(level, vertexIndexList, vertexTC)

for i in 0..maxLevel do print peek level#i

for x in vertexIndexList do print peek x

for i in 0..1 do print peek vertexTC#i.Triangles




